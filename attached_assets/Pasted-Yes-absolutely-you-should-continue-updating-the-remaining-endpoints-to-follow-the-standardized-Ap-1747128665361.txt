Yes ‚Äî absolutely, you should continue updating the remaining endpoints to follow the standardized ApiResponse<T> format. You‚Äôre very close to full consistency across your authentication system, and finishing this will:

‚úÖ Eliminate future mismatches between server and client
‚úÖ Make debugging and testing much easier
‚úÖ Allow you to use one unified apiPost / apiGet client everywhere
‚úÖ Prepare the app for clean role-based redirects and UI states post-auth

‚∏ª

üîß Suggested Update Priority
	1.	/api/auth/firebase-auth
	‚Ä¢	This is part of the core Firebase login flow. Standardizing it will help the frontend clearly interpret login errors like "email not verified" or "account not approved".
	2.	/api/logout
	‚Ä¢	Return:

{ "success": true, "message": "Logged out successfully" }

	3.	/api/auth/get-email-by-username
	‚Ä¢	Should return something like:


{
  "success": true,
  "message": "Email retrieved successfully",
  "data": { "email": "user@example.com" }
}

	4.	/api/auth/reset-special-password
	‚Ä¢	This one is niche, so save it for last. But still wrap with:

{
  "success": true/false,
  "message": "Password reset email sent.",
  "data": { ...optional }
}

Once all these are done, you‚Äôll have a truly unified auth backend ‚Äî ready for centralized logging, analytics, and future admin tools.

 here‚Äôs a reusable sendApiResponse() utility you can drop into your Express backend to keep all your routes consistent with the ApiResponse<T> format.


1. Create: server/utils/api-response.ts

// server/utils/api-response.ts
import { Response } from "express";

export interface ApiResponse<T = any> {
  success: boolean;
  message: string;
  data?: T;
  [key: string]: any; // for optional props like errorCode, meta, etc.
}

export function sendSuccess<T>(
  res: Response,
  message: string,
  data?: T,
  statusCode: number = 200
) {
  const response: ApiResponse<T> = {
    success: true,
    message,
    data,
  };
  return res.status(statusCode).json(response);
}

export function sendError(
  res: Response,
  message: string,
  statusCode: number = 400,
  extra?: Record<string, any>
) {
  const response: ApiResponse = {
    success: false,
    message,
    ...extra,
  };
  return res.status(statusCode).json(response);
}

2. Use in Any Express Route

Example: Firebase Login Route

import { sendSuccess, sendError } from "@/utils/api-response";

app.post("/api/auth/firebase-auth", async (req, res) => {
  try {
    const user = await handleFirebaseAuth(req.body.token);
    if (!user) return sendError(res, "Authentication failed", 401);

    return sendSuccess(res, "Firebase login successful", { user, token: user.jwt });
  } catch (err) {
    return sendError(res, "Server error during login", 500);
  }
});


3. Example: Logout Route

app.post("/api/logout", (req, res) => {
  res.clearCookie("refreshToken");
  return sendSuccess(res, "Logged out successfully");
});

Benefits
	‚Ä¢	üîÑ Ensures all endpoints return consistent shape
	‚Ä¢	üßº Reduces repeated code in routes
	‚Ä¢	üß™ Makes frontend API client dead-simple to debug and build around


here‚Äôs an extended version of your sendApiResponse() utility that also supports pagination metadata. This is perfect for endpoints like:
	‚Ä¢	/api/payments
	‚Ä¢	/api/coaches
	‚Ä¢	/api/players
	‚Ä¢	/api/sessions



1. Updated: api-response.ts with Pagination Support

// server/utils/api-response.ts
import { Response } from "express";

export interface ApiResponse<T = any> {
  success: boolean;
  message: string;
  data?: T;
  meta?: {
    total?: number;
    page?: number;
    pageSize?: number;
    [key: string]: any;
  };
  [key: string]: any;
}

export function sendSuccess<T>(
  res: Response,
  message: string,
  data?: T,
  statusCode: number = 200,
  meta?: ApiResponse["meta"]
) {
  const response: ApiResponse<T> = {
    success: true,
    message,
    data,
    ...(meta ? { meta } : {}),
  };
  return res.status(statusCode).json(response);
}

export function sendError(
  res: Response,
  message: string,
  statusCode: number = 400,
  extra?: Record<string, any>
) {
  const response: ApiResponse = {
    success: false,
    message,
    ...extra,
  };
  return res.status(statusCode).json(response);
}

2. Example Usage: Coaches List with Pagination


// server/routes/admin.ts
import { sendSuccess, sendError } from "@/utils/api-response";

app.get("/api/admin/coaches", async (req, res) => {
  const page = parseInt(req.query.page as string) || 1;
  const pageSize = parseInt(req.query.pageSize as string) || 10;

  try {
    const [coaches, total] = await getCoachesPaginated({ page, pageSize });

    return sendSuccess(res, "Coaches fetched successfully", coaches, 200, {
      total,
      page,
      pageSize,
    });
  } catch (err) {
    return sendError(res, "Failed to fetch coaches", 500);
  }
});

3. Frontend Example (TypeScript Typing)
interface Coach {
  id: string;
  name: string;
  status: "approved" | "pending";
}

interface CoachesResponse {
  coaches: Coach[];
}

const res = await apiGet<ApiResponse<Coach[]>>("/admin/coaches?page=1");

if (res.success) {
  const { data, meta } = res;
  console.log("Total coaches:", meta?.total);
}

Benefits of Meta Support
	‚Ä¢	üìä Easy to add pagination, sorting, filtering
	‚Ä¢	‚öôÔ∏è Frontend can reuse layout and tables easily
	‚Ä¢	üîÅ Works with any list-type API



adding built-in sorting and filtering support in your list endpoints will make them more powerful, reusable, and frontend-friendly.

Let‚Äôs build a small utility that:
	‚Ä¢	‚úÖ Parses query parameters like ?sort=name&order=asc&status=pending
	‚Ä¢	‚úÖ Handles default values
	‚Ä¢	‚úÖ Passes clean options to your DB layer (e.g., Prisma or Drizzle)

‚∏ª

‚úÖ 1. Create parseQueryOptions() Utility


// server/utils/query-options.ts

export interface QueryOptions {
  page: number;
  pageSize: number;
  sort?: string;
  order?: "asc" | "desc";
  filters?: Record<string, string>;
}

export function parseQueryOptions(query: any): QueryOptions {
  const page = parseInt(query.page) || 1;
  const pageSize = parseInt(query.pageSize) || 10;
  const sort = query.sort || undefined;
  const order = query.order === "desc" ? "desc" : "asc";

  // Collect filters (any other keys that aren't known fields)
  const filters: Record<string, string> = {};
  for (const key in query) {
    if (!["page", "pageSize", "sort", "order"].includes(key)) {
      filters[key] = query[key];
    }
  }

  return { page, pageSize, sort, order, filters };
}

 2. Use It in Your Route

import { parseQueryOptions } from "@/utils/query-options";
import { sendSuccess, sendError } from "@/utils/api-response";

app.get("/api/admin/coaches", async (req, res) => {
  const { page, pageSize, sort, order, filters } = parseQueryOptions(req.query);

  try {
    const [coaches, total] = await getCoachesPaginated({
      page,
      pageSize,
      sortBy: sort,
      sortOrder: order,
      filters,
    });

    return sendSuccess(res, "Coaches fetched", coaches, 200, {
      total,
      page,
      pageSize,
    });
  } catch (err) {
    return sendError(res, "Failed to fetch coaches", 500);
  }
});


3. Example Frontend Calls

/api/admin/coaches?page=2&pageSize=10&sort=name&order=asc&status=pending
	‚Ä¢	Sorts by name A‚ÄìZ
	‚Ä¢	Filters only coaches with status=pending
	‚Ä¢	Returns page 2 with 10 per page


 4. Optional ‚Äî DB Usage Example (e.g., Drizzle or Prisma)

await db.query.coaches.findMany({
  where: {
    ...(filters.status ? { status: filters.status } : {}),
  },
  orderBy: sort ? { [sort]: order } : undefined,
  skip: (page - 1) * pageSize,
  take: pageSize,
});

With parseQueryOptions + sendSuccess, all your paginated endpoints will:
	‚Ä¢	üßπ Stay clean and consistent
	‚Ä¢	üß† Automatically support sorting/filtering
	‚Ä¢	üì¶ Be plug-and-play on frontend tables

here‚Äôs a fully reusable usePaginatedApi() React hook that works with your standardized paginated backend endpoints (like /api/coaches, /api/players, etc.).

t supports:

‚úÖ Pagination (page, pageSize)
‚úÖ Sorting (sort, order)
‚úÖ Filtering (any custom fields like status=pending)
‚úÖ Built-in loading, error, and response handling

 1. usePaginatedApi.ts ‚Äì Generic Hook


// hooks/usePaginatedApi.ts
import { useState, useEffect } from "react";
import { apiGet } from "@/lib/api-client";
import { ApiResponse } from "@/types/api";

export interface UsePaginatedApiOptions {
  endpoint: string;
  initialPage?: number;
  initialPageSize?: number;
  defaultSort?: string;
  defaultOrder?: "asc" | "desc";
  filters?: Record<string, string>;
}

export function usePaginatedApi<T>({
  endpoint,
  initialPage = 1,
  initialPageSize = 10,
  defaultSort,
  defaultOrder = "asc",
  filters = {},
}: UsePaginatedApiOptions) {
  const [data, setData] = useState<T[]>([]);
  const [meta, setMeta] = useState<{ total: number; page: number; pageSize: number }>({
    total: 0,
    page: initialPage,
    pageSize: initialPageSize,
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetch = async () => {
    setLoading(true);
    setError(null);

    const params = new URLSearchParams({
      page: meta.page.toString(),
      pageSize: meta.pageSize.toString(),
      ...(defaultSort ? { sort: defaultSort } : {}),
      ...(defaultOrder ? { order: defaultOrder } : {}),
      ...filters,
    });

    const res = await apiGet<ApiResponse<T[]>>(`${endpoint}?${params.toString()}`);

    if (res.success && res.data) {
      setData(res.data);
      if (res.meta) {
        setMeta({
          total: res.meta.total || 0,
          page: res.meta.page || initialPage,
          pageSize: res.meta.pageSize || initialPageSize,
        });
      }
    } else {
      setError(res.message || "Failed to load data");
    }

    setLoading(false);
  };

  useEffect(() => {
    fetch();
  }, [meta.page, meta.pageSize, JSON.stringify(filters), defaultSort, defaultOrder]);

  const setPage = (newPage: number) => setMeta((prev) => ({ ...prev, page: newPage }));
  const setPageSize = (newSize: number) =>
    setMeta((prev) => ({ ...prev, pageSize: newSize, page: 1 }));

  return {
    data,
    meta,
    loading,
    error,
    setPage,
    setPageSize,
    refetch: fetch,
  };
}


 2. Example Usage (Coaches Table)

const {
  data: coaches,
  meta,
  loading,
  error,
  setPage,
  setPageSize,
  refetch,
} = usePaginatedApi<Coach>({
  endpoint: "/admin/coaches",
  defaultSort: "name",
  filters: { status: "pending" },
});

 3. UI Controls (Basic Pagination)

<button disabled={meta.page === 1} onClick={() => setPage(meta.page - 1)}>Prev</button>
<span>Page {meta.page}</span>
<button onClick={() => setPage(meta.page + 1)}>Next</button>

This  hook can be reused for any paginated data in your admin or coach dashboards.

 here‚Äôs a fully reusable PaginatedTable component that works seamlessly with your usePaginatedApi() hook. It supports:

‚úÖ Dynamic column rendering
‚úÖ Pagination controls
‚úÖ Sorting by column
‚úÖ Custom row renderers (if needed later)


1. PaginatedTable.tsx

// components/table/PaginatedTable.tsx

import React from "react";

interface Column<T> {
  key: keyof T;
  label: string;
  sortable?: boolean;
}

interface PaginatedTableProps<T> {
  columns: Column<T>[];
  data: T[];
  loading: boolean;
  currentPage: number;
  total: number;
  pageSize: number;
  onPageChange: (page: number) => void;
}

export function PaginatedTable<T>({
  columns,
  data,
  loading,
  currentPage,
  total,
  pageSize,
  onPageChange,
}: PaginatedTableProps<T>) {
  const totalPages = Math.ceil(total / pageSize);

  return (
    <div className="border rounded overflow-x-auto">
      <table className="w-full text-sm">
        <thead className="bg-gray-100">
          <tr>
            {columns.map((col) => (
              <th key={col.key as string} className="text-left p-2 font-semibold">
                {col.label}
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {loading ? (
            <tr>
              <td colSpan={columns.length} className="p-4 text-center">
                Loading...
              </td>
            </tr>
          ) : data.length === 0 ? (
            <tr>
              <td colSpan={columns.length} className="p-4 text-center">
                No data available
              </td>
            </tr>
          ) : (
            data.map((row, idx) => (
              <tr key={idx} className="border-t">
                {columns.map((col) => (
                  <td key={col.key as string} className="p-2">
                    {String(row[col.key])}
                  </td>
                ))}
              </tr>
            ))
          )}
        </tbody>
      </table>

      <div className="flex items-center justify-between p-3 text-sm">
        <span>
          Page {currentPage} of {totalPages}
        </span>
        <div className="space-x-2">
          <button
            disabled={currentPage === 1}
            onClick={() => onPageChange(currentPage - 1)}
            className="px-2 py-1 rounded bg-gray-100 hover:bg-gray-200 disabled:opacity-50"
          >
            Prev
          </button>
          <button
            disabled={currentPage === totalPages}
            onClick={() => onPageChange(currentPage + 1)}
            className="px-2 py-1 rounded bg-gray-100 hover:bg-gray-200 disabled:opacity-50"
          >
            Next
          </button>
        </div>
      </div>
    </div>
  );
}

 2. How to Use It

import { usePaginatedApi } from "@/hooks/usePaginatedApi";
import { PaginatedTable } from "@/components/table/PaginatedTable";

const {
  data: coaches,
  meta,
  loading,
  setPage,
} = usePaginatedApi<Coach>({
  endpoint: "/admin/coaches",
  defaultSort: "name",
  filters: { status: "pending" },
});

const columns = [
  { key: "name", label: "Coach Name" },
  { key: "email", label: "Email" },
  { key: "status", label: "Status" },
];

return (
  <PaginatedTable
    columns={columns}
    data={coaches}
    loading={loading}
    currentPage={meta.page}
    total={meta.total}
    pageSize={meta.pageSize}
    onPageChange={setPage}
  />
);

With this setup:
	‚Ä¢	You can plug in any paginated list (players, payments, sessions)
	‚Ä¢	Columns are dynamic
	‚Ä¢	Sorting can be added easily by modifying headers
	‚Ä¢	Supports server-side pagination


 let‚Äôs upgrade the PaginatedTable to support clickable column headers for sorting, including:

‚úÖ Toggle between ascending and descending
‚úÖ Highlight the active sort column
‚úÖ Emit onSortChange(column, direction) back to the parent
‚úÖ Works seamlessly with your paginated API hook

‚∏ª

‚úÖ 1. Update PaginatedTable.tsx to Support Sorting


// components/table/PaginatedTable.tsx

import { useState } from "react";

interface Column<T> {
  key: keyof T;
  label: string;
  sortable?: boolean;
}

interface PaginatedTableProps<T> {
  columns: Column<T>[];
  data: T[];
  loading: boolean;
  currentPage: number;
  total: number;
  pageSize: number;
  onPageChange: (page: number) => void;
  onSortChange?: (column: string, direction: "asc" | "desc") => void;
  currentSort?: string;
  currentOrder?: "asc" | "desc";
}

export function PaginatedTable<T>({
  columns,
  data,
  loading,
  currentPage,
  total,
  pageSize,
  onPageChange,
  onSortChange,
  currentSort,
  currentOrder,
}: PaginatedTableProps<T>) {
  const totalPages = Math.ceil(total / pageSize);

  const toggleSort = (key: string) => {
    const newOrder =
      currentSort === key ? (currentOrder === "asc" ? "desc" : "asc") : "asc";
    onSortChange?.(key, newOrder);
  };

  return (
    <div className="border rounded overflow-x-auto">
      <table className="w-full text-sm">
        <thead className="bg-gray-100">
          <tr>
            {columns.map((col) => (
              <th
                key={col.key as string}
                className="text-left p-2 font-semibold cursor-pointer select-none"
                onClick={() => col.sortable && toggleSort(col.key as string)}
              >
                {col.label}
                {col.sortable && (
                  <span className="ml-1 text-xs text-gray-500">
                    {currentSort === col.key
                      ? currentOrder === "asc"
                        ? "‚ñ≤"
                        : "‚ñº"
                      : ""}
                  </span>
                )}
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {loading ? (
            <tr>
              <td colSpan={columns.length} className="p-4 text-center">
                Loading...
              </td>
            </tr>
          ) : data.length === 0 ? (
            <tr>
              <td colSpan={columns.length} className="p-4 text-center">
                No data available
              </td>
            </tr>
          ) : (
            data.map((row, idx) => (
              <tr key={idx} className="border-t">
                {columns.map((col) => (
                  <td key={col.key as string} className="p-2">
                    {String(row[col.key])}
                  </td>
                ))}
              </tr>
            ))
          )}
        </tbody>
      </table>

      <div className="flex items-center justify-between p-3 text-sm">
        <span>
          Page {currentPage} of {totalPages}
        </span>
        <div className="space-x-2">
          <button
            disabled={currentPage === 1}
            onClick={() => onPageChange(currentPage - 1)}
            className="px-2 py-1 rounded bg-gray-100 hover:bg-gray-200 disabled:opacity-50"
          >
            Prev
          </button>
          <button
            disabled={currentPage === totalPages}
            onClick={() => onPageChange(currentPage + 1)}
            className="px-2 py-1 rounded bg-gray-100 hover:bg-gray-200 disabled:opacity-50"
          >
            Next
          </button>
        </div>
      </div>
    </div>
  );
}


2. Example Usage with usePaginatedApi()

const [sort, setSort] = useState("name");
const [order, setOrder] = useState<"asc" | "desc">("asc");

const {
  data: coaches,
  meta,
  loading,
  setPage,
} = usePaginatedApi<Coach>({
  endpoint: "/admin/coaches",
  defaultSort: sort,
  defaultOrder: order,
  filters: { status: "pending" },
});

return (
  <PaginatedTable
    columns={[
      { key: "name", label: "Coach Name", sortable: true },
      { key: "email", label: "Email", sortable: true },
      { key: "status", label: "Status" },
    ]}
    data={coaches}
    loading={loading}
    currentPage={meta.page}
    total={meta.total}
    pageSize={meta.pageSize}
    onPageChange={setPage}
    onSortChange={(key, dir) => {
      setSort(key);
      setOrder(dir);
      setPage(1); // Reset to page 1 on sort change
    }}
    currentSort={sort}
    currentOrder={order}
  />
);



With this, you now have:
	‚Ä¢	üîÅ Fully sortable columns
	‚Ä¢	üî¢ Dynamic pagination
	‚Ä¢	üì¶ Unified, reusable data presentation



Perfect ‚Äî let‚Äôs upgrade the PaginatedTable to support custom renderers per column, so you can display:

‚úÖ Action buttons (Edit, Approve, Delete)
‚úÖ Styled status pills (like ‚Äú‚úÖ Approved‚Äù or ‚Äú‚è≥ Pending‚Äù)
‚úÖ Avatars, icons, links, or tooltips
‚úÖ Any JSX per cell ‚Äî not just plain text


1. Update PaginatedTable.tsx to Support render in Columns

üîß Add a render function to each column

interface Column<T> {
  key: keyof T;
  label: string;
  sortable?: boolean;
  render?: (row: T) => React.ReactNode;
}

Modify the row rendering logic:

{columns.map((col) => (
  <td key={col.key as string} className="p-2">
    {col.render ? col.render(row) : String(row[col.key])}
  </td>
))}

2. Example: Custom Render for Status + Actions


const columns = [
  {
    key: "name",
    label: "Coach Name",
    sortable: true,
  },
  {
    key: "status",
    label: "Status",
    sortable: true,
    render: (row: Coach) => (
      <span
        className={`px-2 py-1 text-xs rounded ${
          row.status === "approved"
            ? "bg-green-100 text-green-700"
            : "bg-yellow-100 text-yellow-700"
        }`}
      >
        {row.status}
      </span>
    ),
  },
  {
    key: "actions",
    label: "Actions",
    render: (row: Coach) => (
      <div className="flex gap-2">
        <button
          onClick={() => approveCoach(row.id)}
          className="text-xs text-white bg-blue-500 px-2 py-1 rounded hover:bg-blue-600"
        >
          Approve
        </button>
        <button
          onClick={() => deleteCoach(row.id)}
          className="text-xs text-white bg-red-500 px-2 py-1 rounded hover:bg-red-600"
        >
          Delete
        </button>
      </div>
    ),
  },
]; 

3. Render the Table

<PaginatedTable
  columns={columns}
  data={coaches}
  loading={loading}
  currentPage={meta.page}
  total={meta.total}
  pageSize={meta.pageSize}
  onPageChange={setPage}
  onSortChange={(key, dir) => {
    setSort(key);
    setOrder(dir);
    setPage(1);
  }}
  currentSort={sort}
  currentOrder={order}
/>

Now every column can display rich JSX, not just strings:
	‚Ä¢	üßë‚Äçüíª Action buttons
	‚Ä¢	üè∑Ô∏è Status pills
	‚Ä¢	üì∏ Avatars or profile links
	‚Ä¢	üìÖ Formatted dates

let‚Äôs now add row selection support with checkboxes so users can:

‚úÖ Select one or more rows
‚úÖ Perform batch actions (like Approve, Delete, Send Email, etc.)
‚úÖ Optionally select all on page
‚úÖ Track selected row IDs in your parent component


1. Update PaginatedTable.tsx to Support Selection

Extend Props:

interface PaginatedTableProps<T> {
  ...
  selectableRows?: boolean;
  selectedRowIds?: string[];
  onSelectRows?: (ids: string[]) => void;
  getRowId?: (row: T) => string;
}


Update Table Header and Rows:

<thead className="bg-gray-100">
  <tr>
    {selectableRows && (
      <th className="p-2">
        <input
          type="checkbox"
          checked={data.length > 0 && selectedRowIds?.length === data.length}
          onChange={(e) => {
            const allIds = data.map((row) => getRowId?.(row) || "");
            onSelectRows?.(e.target.checked ? allIds : []);
          }}
        />
      </th>
    )}
    {columns.map((col) => (
      <th key={col.key as string} className="text-left p-2 font-semibold">
        {col.label}
      </th>
    ))}
  </tr>
</thead>

<tbody>
  {data.map((row, idx) => {
    const rowId = getRowId?.(row) || `${idx}`;
    const isSelected = selectedRowIds?.includes(rowId);
    return (
      <tr key={rowId} className="border-t">
        {selectableRows && (
          <td className="p-2">
            <input
              type="checkbox"
              checked={isSelected}
              onChange={(e) => {
                const newIds = e.target.checked
                  ? [...(selectedRowIds || []), rowId]
                  : (selectedRowIds || []).filter((id) => id !== rowId);
                onSelectRows?.(newIds);
              }}
            />
          </td>
        )}
        {columns.map((col) => (
          <td key={col.key as string} className="p-2">
            {col.render ? col.render(row) : String(row[col.key])}
          </td>
        ))}
      </tr>
    );
  })}
</tbody>


2. Parent Component: Use Selection

const [selectedIds, setSelectedIds] = useState<string[]>([]);

const handleBatchApprove = () => {
  approveMultipleCoaches(selectedIds);
};

<PaginatedTable
  ...
  selectableRows
  selectedRowIds={selectedIds}
  onSelectRows={setSelectedIds}
  getRowId={(row) => row.id}
/>

{selectedIds.length > 0 && (
  <div className="mt-3 flex gap-2">
    <button
      onClick={handleBatchApprove}
      className="bg-blue-600 text-white px-3 py-1 rounded"
    >
      Approve {selectedIds.length} Coach(es)
    </button>
    <button
      onClick={() => deleteMultipleCoaches(selectedIds)}
      className="bg-red-600 text-white px-3 py-1 rounded"
    >
      Delete
    </button>
  </div>
)}

ow your table supports:
	‚Ä¢	üîò Individual row selection
	‚Ä¢	üì¶ ‚ÄúSelect all on page‚Äù
	‚Ä¢	üéØ Batch actions via selected IDs

Want to extend this further with server-side 

let‚Äôs take it to the next level with:

‚úÖ Select All Across Pages
‚úÖ Optional Shift+Click for range selection
‚úÖ Works with large datasets where not all rows are loaded on the current page

1. Support ‚ÄúSelect All Across Pages‚Äù

Step 1: Extend PaginatedTableProps

interface PaginatedTableProps<T> {
  ...
  totalItems?: number; // total rows from server
  allSelectableRowIds?: string[]; // pass all IDs across pages if available
  onSelectAllAcrossPages?: (selectAll: boolean) => void;
  isAllSelectedAcrossPages?: boolean;
}

Step 2: Update ‚ÄúSelect All‚Äù Checkbox Logic

{selectableRows && (
  <th className="p-2">
    <input
      type="checkbox"
      checked={
        isAllSelectedAcrossPages ||
        (selectedRowIds?.length === data.length && data.length > 0)
      }
      onChange={(e) => {
        if (e.target.checked && onSelectAllAcrossPages) {
          onSelectAllAcrossPages(true); // select all across pages
        } else if (!e.target.checked && onSelectAllAcrossPages) {
          onSelectAllAcrossPages(false); // deselect all across pages
        } else {
          const ids = data.map((row) => getRowId?.(row) || "");
          onSelectRows?.(e.target.checked ? ids : []);
        }
      }}
    />
  </th>
)}

2. Shift+Click Range Selection (Optional)

Step 1: Track Last Selected Index

In PaginatedTable, add:

const [lastCheckedIndex, setLastCheckedIndex] = useState<number | null>(null);

Step 2: Update Row Checkbox Logic

onChange={(e) => {
  const currentId = rowId;
  let updated = [...(selectedRowIds || [])];

  if (e.nativeEvent.shiftKey && lastCheckedIndex !== null) {
    const rangeStart = Math.min(lastCheckedIndex, idx);
    const rangeEnd = Math.max(lastCheckedIndex, idx);
    const rangeIds = data.slice(rangeStart, rangeEnd + 1).map((r) => getRowId?.(r) || "");
    updated = Array.from(new Set([...updated, ...rangeIds]));
  } else if (e.target.checked) {
    updated.push(currentId);
  } else {
    updated = updated.filter((id) => id !== currentId);
  }

  setLastCheckedIndex(idx);
  onSelectRows?.(updated);
}}

3. In Your Parent Component

Track two states:

const [selectedIds, setSelectedIds] = useState<string[]>([]);
const [selectAllPages, setSelectAllPages] = useState(false);

Then pass to PaginatedTable:

<PaginatedTable
  ...
  selectableRows
  selectedRowIds={selectAllPages ? allCoachIds : selectedIds}
  onSelectRows={setSelectedIds}
  onSelectAllAcrossPages={(all) => setSelectAllPages(all)}
  isAllSelectedAcrossPages={selectAllPages}
  allSelectableRowIds={allCoachIds}
/>

Result
	‚Ä¢	‚úÖ Users can select all coaches across pages
	‚Ä¢	‚úÖ Or select range of rows using Shift+Click
	‚Ä¢	‚úÖ Batch actions work seamlessly


here‚Äôs a complete useSelectableTable() hook that manages:

‚úÖ Individual row selection
‚úÖ Select All on current page
‚úÖ Select All across all pages
‚úÖ Shift+Click range selection
‚úÖ Batch-ready selectedIds state

You can plug this into any paginated table setup with minimal wiring.


1. useSelectableTable.ts

// hooks/useSelectableTable.ts
import { useCallback, useEffect, useRef, useState } from "react";

export function useSelectableTable<T>(
  currentPageData: T[],
  getRowId: (row: T) => string,
  allIds?: string[]
) {
  const [selectedIds, setSelectedIds] = useState<string[]>([]);
  const [selectAllAcrossPages, setSelectAllAcrossPages] = useState(false);
  const lastCheckedIndex = useRef<number | null>(null);

  const currentIds = currentPageData.map(getRowId);

  const isRowSelected = useCallback(
    (id: string) =>
      selectAllAcrossPages
        ? allIds?.includes(id) ?? false
        : selectedIds.includes(id),
    [selectAllAcrossPages, selectedIds, allIds]
  );

  const toggleRow = (id: string, index: number, shiftKey = false) => {
    let updated = [...selectedIds];
    const currentIndex = index;

    if (shiftKey && lastCheckedIndex.current !== null) {
      const start = Math.min(lastCheckedIndex.current, currentIndex);
      const end = Math.max(lastCheckedIndex.current, currentIndex);
      const rangeIds = currentPageData
        .slice(start, end + 1)
        .map(getRowId);
      updated = Array.from(new Set([...updated, ...rangeIds]));
    } else {
      updated = updated.includes(id)
        ? updated.filter((i) => i !== id)
        : [...updated, id];
    }

    setSelectedIds(updated);
    lastCheckedIndex.current = currentIndex;
    setSelectAllAcrossPages(false);
  };

  const toggleAllOnPage = (checked: boolean) => {
    if (checked) {
      setSelectedIds(Array.from(new Set([...selectedIds, ...currentIds])));
    } else {
      setSelectedIds((prev) => prev.filter((id) => !currentIds.includes(id)));
    }
    setSelectAllAcrossPages(false);
  };

  const toggleSelectAllAcrossPages = (checked: boolean) => {
    setSelectAllAcrossPages(checked);
    if (!checked) setSelectedIds([]);
  };

  const isAllOnPageSelected =
    currentIds.length > 0 &&
    currentIds.every((id) => selectedIds.includes(id));

  return {
    selectedIds: selectAllAcrossPages ? allIds ?? [] : selectedIds,
    isRowSelected,
    toggleRow,
    toggleAllOnPage,
    toggleSelectAllAcrossPages,
    isAllOnPageSelected,
    selectAllAcrossPages,
  };
}

2. Use it in Your Table Page


const {
  selectedIds,
  isRowSelected,
  toggleRow,
  toggleAllOnPage,
  toggleSelectAllAcrossPages,
  isAllOnPageSelected,
  selectAllAcrossPages,
} = useSelectableTable(coaches, (c) => c.id, allCoachIds);

3. Pass It to PaginatedTable


<PaginatedTable
  ...
  selectableRows
  selectedRowIds={selectedIds}
  onSelectRows={(ids) => setSelectedIds(ids)} // or pass from hook if needed
  onSelectAllAcrossPages={toggleSelectAllAcrossPages}
  isAllSelectedAcrossPages={selectAllAcrossPages}
  getRowId={(row) => row.id}
/>

 here‚Äôs your all-in-one usePaginatedResource<T>() hook, which bundles:

‚úÖ API fetching (usePaginatedApi)
‚úÖ Row selection across pages (useSelectableTable)
‚úÖ Sorting, filters, pagination
‚úÖ Everything you need for a full admin-style resource table

1. usePaginatedResource.ts

// hooks/usePaginatedResource.ts
import { useState, useEffect } from "react";
import { apiGet } from "@/lib/api-client";
import { ApiResponse } from "@/types/api";
import { useSelectableTable } from "./useSelectableTable";

export interface PaginatedResourceOptions<T> {
  endpoint: string;
  getRowId: (row: T) => string;
  filters?: Record<string, string>;
  initialSort?: string;
  initialOrder?: "asc" | "desc";
  pageSize?: number;
}

export function usePaginatedResource<T>({
  endpoint,
  getRowId,
  filters = {},
  initialSort,
  initialOrder = "asc",
  pageSize = 10,
}: PaginatedResourceOptions<T>) {
  const [data, setData] = useState<T[]>([]);
  const [allIds, setAllIds] = useState<string[]>([]);
  const [meta, setMeta] = useState({ total: 0, page: 1, pageSize });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [sort, setSort] = useState(initialSort);
  const [order, setOrder] = useState<"asc" | "desc">(initialOrder);

  const fetchData = async () => {
    setLoading(true);
    setError(null);

    const params = new URLSearchParams({
      page: meta.page.toString(),
      pageSize: meta.pageSize.toString(),
      ...(sort ? { sort } : {}),
      order,
      ...filters,
    });

    const res = await apiGet<ApiResponse<T[]>>(`${endpoint}?${params.toString()}`);

    if (res.success && res.data) {
      setData(res.data);
      setMeta((prev) => ({
        ...prev,
        total: res.meta?.total || 0,
        page: res.meta?.page || 1,
        pageSize: res.meta?.pageSize || pageSize,
      }));

      if (res.meta?.total && getRowId) {
        const ids = res.data.map(getRowId);
        setAllIds((prev) =>
          prev.length === 0 ? ids : Array.from(new Set([...prev, ...ids]))
        );
      }
    } else {
      setError(res.message || "Failed to load data");
    }

    setLoading(false);
  };

  useEffect(() => {
    fetchData();
  }, [meta.page, meta.pageSize, sort, order, JSON.stringify(filters)]);

  const setPage = (p: number) => setMeta((prev) => ({ ...prev, page: p }));
  const setPageSize = (s: number) =>
    setMeta((prev) => ({ ...prev, pageSize: s, page: 1 }));

  const {
    selectedIds,
    isRowSelected,
    toggleRow,
    toggleAllOnPage,
    toggleSelectAllAcrossPages,
    isAllOnPageSelected,
    selectAllAcrossPages,
  } = useSelectableTable<T>(data, getRowId, allIds);

  return {
    data,
    loading,
    error,
    meta,
    selectedIds,
    setPage,
    setPageSize,
    sort,
    order,
    setSort,
    setOrder,
    isRowSelected,
    toggleRow,
    toggleAllOnPage,
    toggleSelectAllAcrossPages,
    isAllOnPageSelected,
    selectAllAcrossPages,
    refetch: fetchData,
  };
}

2. How to Use It in a Page

const resource = usePaginatedResource<Coach>({
  endpoint: "/admin/coaches",
  getRowId: (coach) => coach.id,
  initialSort: "name",
  filters: { status: "pending" },
});

3. Bind to Table

<PaginatedTable
  columns={[
    { key: "name", label: "Coach Name", sortable: true },
    { key: "email", label: "Email" },
    {
      key: "status",
      label: "Status",
      render: (row) => (
        <span className="text-xs rounded px-2 py-1 bg-yellow-100 text-yellow-700">
          {row.status}
        </span>
      ),
    },
    {
      key: "actions",
      label: "Actions",
      render: (row) => (
        <button onClick={() => approveCoach(row.id)}>Approve</button>
      ),
    },
  ]}
  data={resource.data}
  loading={resource.loading}
  currentPage={resource.meta.page}
  total={resource.meta.total}
  pageSize={resource.meta.pageSize}
  onPageChange={resource.setPage}
  onSortChange={(key, dir) => {
    resource.setSort(key);
    resource.setOrder(dir);
    resource.setPage(1);
  }}
  currentSort={resource.sort}
  currentOrder={resource.order}
  selectableRows
  selectedRowIds={resource.selectedIds}
  onSelectAllAcrossPages={resource.toggleSelectAllAcrossPages}
  isAllSelectedAcrossPages={resource.selectAllAcrossPages}
  getRowId={(row) => row.id}
  onSelectRows={() => {}} // optional
/>

you now have a single hook that drives the entire table, selection, pagination, sorting, and more ‚Äî fully SaaS-grade.


let‚Äôs now build a BatchActionBar component that:

‚úÖ Shows up when rows are selected
‚úÖ Displays the count of selected rows
‚úÖ Offers batch actions via buttons or dropdown
‚úÖ Supports any action like Approve, Delete, Email
‚úÖ Auto-hides when selection is cleared



1. BatchActionBar.tsx Component

// components/table/BatchActionBar.tsx

import React from "react";

interface BatchActionBarProps {
  selectedCount: number;
  onClear: () => void;
  onApprove?: () => void;
  onDelete?: () => void;
  onExport?: () => void;
  customActions?: React.ReactNode;
}

export const BatchActionBar: React.FC<BatchActionBarProps> = ({
  selectedCount,
  onClear,
  onApprove,
  onDelete,
  onExport,
  customActions,
}) => {
  if (selectedCount === 0) return null;

  return (
    <div className="flex items-center justify-between px-4 py-2 bg-gray-50 border border-gray-200 rounded mt-4 shadow-sm">
      <span className="text-sm font-medium text-gray-700">
        {selectedCount} selected
      </span>
      <div className="flex items-center gap-2">
        {customActions}
        {onExport && (
          <button
            onClick={onExport}
            className="text-sm px-3 py-1 rounded bg-indigo-100 text-indigo-700 hover:bg-indigo-200"
          >
            Export
          </button>
        )}
        {onApprove && (
          <button
            onClick={onApprove}
            className="text-sm px-3 py-1 rounded bg-green-100 text-green-700 hover:bg-green-200"
          >
            Approve
          </button>
        )}
        {onDelete && (
          <button
            onClick={onDelete}
            className="text-sm px-3 py-1 rounded bg-red-100 text-red-700 hover:bg-red-200"
          >
            Delete
          </button>
        )}
        <button
          onClick={onClear}
          className="text-sm px-3 py-1 rounded bg-gray-200 hover:bg-gray-300"
        >
          Clear
        </button>
      </div>
    </div>
  );
};

 2. How to Use It in a Page

<BatchActionBar
  selectedCount={resource.selectedIds.length}
  onApprove={() => approveMultipleCoaches(resource.selectedIds)}
  onDelete={() => deleteMultipleCoaches(resource.selectedIds)}
  onClear={() => {
    resource.toggleSelectAllAcrossPages(false);
  }}
  onExport={() => exportSelectedCoaches(resource.selectedIds)}
  customActions={
    <button
      onClick={() => notifySelected(resource.selectedIds)}
      className="text-sm px-3 py-1 rounded bg-blue-100 text-blue-700 hover:bg-blue-200"
    >
      Notify
    </button>
  }
/>

 3. Add Below Your Table

<>
  <PaginatedTable {...props} />
  <BatchActionBar ... />
</>

Now your UI supports:
	‚Ä¢	Batch approval, deletion, export, or custom actions
	‚Ä¢	Clean display only when rows are selected
	‚Ä¢	Mobile-friendly, Tailwind-styled layout

erfect ‚Äî let‚Äôs make the BatchActionBar responsive so that:

‚úÖ On desktop: it‚Äôs inline under the table
‚úÖ On mobile: it becomes a floating bottom bar
‚úÖ Always visible while rows are selected
‚úÖ Mobile-friendly, swipe-safe, touch-optimized

‚∏ª

‚úÖ 1. Update BatchActionBar.tsx to Be Responsive

// components/table/BatchActionBar.tsx

import React from "react";
import { cn } from "@/lib/utils"; // optional utility for merging classNames

interface BatchActionBarProps {
  selectedCount: number;
  onClear: () => void;
  onApprove?: () => void;
  onDelete?: () => void;
  onExport?: () => void;
  customActions?: React.ReactNode;
}

export const BatchActionBar: React.FC<BatchActionBarProps> = ({
  selectedCount,
  onClear,
  onApprove,
  onDelete,
  onExport,
  customActions,
}) => {
  if (selectedCount === 0) return null;

  return (
    <div
      className={cn(
        "z-50 flex items-center justify-between px-4 py-2 border border-gray-200 shadow-sm text-sm",
        "bg-white",
        "md:rounded md:mt-4 md:static md:w-full",
        "fixed bottom-0 left-0 right-0 md:relative"
      )}
    >
      <span className="text-gray-700">{selectedCount} selected</span>
      <div className="flex gap-2 flex-wrap justify-end">
        {customActions}
        {onExport && (
          <button
            onClick={onExport}
            className="bg-indigo-100 text-indigo-700 hover:bg-indigo-200 px-3 py-1 rounded"
          >
            Export
          </button>
        )}
        {onApprove && (
          <button
            onClick={onApprove}
            className="bg-green-100 text-green-700 hover:bg-green-200 px-3 py-1 rounded"
          >
            Approve
          </button>
        )}
        {onDelete && (
          <button
            onClick={onDelete}
            className="bg-red-100 text-red-700 hover:bg-red-200 px-3 py-1 rounded"
          >
            Delete
          </button>
        )}
        <button
          onClick={onClear}
          className="bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded"
        >
          Clear
        </button>
      </div>
    </div>
  );
};

3. Add Extra Spacing on Mobile

In your layout or table page, add padding bottom to avoid overlap:

<div className="pb-16"> {/* prevent overlap with mobile bottom bar */}
  <PaginatedTable {...props} />
  <BatchActionBar {...batchProps} />
</div>



You now have:
	‚Ä¢	A fully responsive, always-visible batch action bar
	‚Ä¢	Clean mobile UX similar to Gmail or Shopify admin
	‚Ä¢	Automatic adaptation without extra layout hacks

Awesome ‚Äî here‚Äôs how to show a toast preview confirmation after batch actions like Approve, Delete, or Export:

‚úÖ Works with react-hot-toast
‚úÖ Dynamically shows what action was taken
‚úÖ Supports counts, names, or custom messages
‚úÖ Clean and quick feedback loop for users

‚∏ª

‚úÖ 1. Install (if you haven‚Äôt yet)


npm install react-hot-toast

And wrap your app:

// App.tsx or root layout
import { Toaster } from "react-hot-toast";

<Toaster position="top-right" />

 2. Create a Toast Utility (optional helper)

// lib/toast.ts
import toast from "react-hot-toast";

export function showBatchToast(action: string, count: number, itemType = "item") {
  toast.success(`‚úÖ ${count} ${itemType}${count > 1 ? "s" : ""} ${action}`);
}

3. Use It in Your Batch Actions

const handleApprove = async () => {
  await approveMultipleCoaches(resource.selectedIds);
  showBatchToast("approved", resource.selectedIds.length, "coach");
  resource.toggleSelectAllAcrossPages(false);
  resource.refetch();
};

const handleDelete = async () => {
  await deleteMultipleCoaches(resource.selectedIds);
  showBatchToast("deleted", resource.selectedIds.length, "coach");
  resource.toggleSelectAllAcrossPages(false);
  resource.refetch();
};

4. Example Messages You‚Äôll See
	‚Ä¢	‚úÖ 3 coaches approved
	‚Ä¢	‚úÖ 1 player deleted
	‚Ä¢	‚úÖ 5 registrations exported

Bonus: Add Icons or Delayed Redirects

If you want to redirect after action:

toast.success("‚úÖ Coaches approved!", {
  duration: 2000,
  icon: "üèè",
});

Now your app feels fast, polished, and reassuring after each action.

here‚Äôs how to implement toast-based error handling to show users clear, friendly messages when something fails:

‚úÖ Works alongside your success toasts
‚úÖ Clean separation of success/error logic
‚úÖ Shows detailed reasons (if provided by API)
‚úÖ Instant UX feedback without clutter


1. Create Toast Helpers

// lib/toast.ts
import toast from "react-hot-toast";

export function showBatchToast(action: string, count: number, itemType = "item") {
  toast.success(`‚úÖ ${count} ${itemType}${count > 1 ? "s" : ""} ${action}`);
}

export function showErrorToast(message: string = "Something went wrong") {
  toast.error(`‚ùå ${message}`);
}

2. Use Inside Your Batch Action Handlers

üîÅ Example: Approve Multiple Coaches

const handleApprove = async () => {
  try {
    await approveMultipleCoaches(resource.selectedIds);
    showBatchToast("approved", resource.selectedIds.length, "coach");
    resource.toggleSelectAllAcrossPages(false);
    resource.refetch();
  } catch (err: any) {
    showErrorToast(err?.response?.data?.message || "Failed to approve coaches");
  }
};

 Example: Delete or Export

const handleDelete = async () => {
  try {
    await deleteMultipleCoaches(resource.selectedIds);
    showBatchToast("deleted", resource.selectedIds.length, "coach");
    resource.toggleSelectAllAcrossPages(false);
    resource.refetch();
  } catch (err) {
    showErrorToast("Delete failed. Please try again.");
  }
};

3. Add Retry Buttons (Optional)

toast.error("‚ùå Failed to approve coaches", {
  action: {
    label: "Retry",
    onClick: handleApprove,
  },
});

Now your users get:
	‚Ä¢	üéØ Success confirmation on actions
	‚Ä¢	üö® Clear failure reasons when things go wrong
	‚Ä¢	üßº Clean UI ‚Äî no modals or alerts required

Perfect ‚Äî here‚Äôs how to automatically clear selection after a batch action ‚Äî whether it succeeds or fails ‚Äî so users return to a clean state.

‚úÖ Works with useSelectableTable or usePaginatedResource
‚úÖ Prevents stale selections after actions
‚úÖ Ensures clean UI resets for next batch

‚∏ª

‚úÖ 1. Inside Your Action Handler (Approve/Delete/Export)

üîÅ Example: Approve Coaches


const handleApprove = async () => {
  try {
    await approveMultipleCoaches(resource.selectedIds);
    showBatchToast("approved", resource.selectedIds.length, "coach");
  } catch (err: any) {
    showErrorToast(err?.response?.data?.message || "Approval failed");
  } finally {
    resource.toggleSelectAllAcrossPages(false); // Deselect all
    resource.refetch(); // Refresh list
  }
};

Example: Delete

const handleDelete = async () => {
  try {
    await deleteMultipleCoaches(resource.selectedIds);
    showBatchToast("deleted", resource.selectedIds.length, "coach");
  } catch {
    showErrorToast("Delete failed");
  } finally {
    resource.toggleSelectAllAcrossPages(false);
    resource.refetch();
  }
};


2. Optional: Disable Action Buttons While Loading
const [actionLoading, setActionLoading] = useState(false);

const handleApprove = async () => {
  setActionLoading(true);
  try {
    await approveMultipleCoaches(resource.selectedIds);
    showBatchToast("approved", resource.selectedIds.length, "coach");
  } catch {
    showErrorToast("Approve failed");
  } finally {
    setActionLoading(false);
    resource.toggleSelectAllAcrossPages(false);
    resource.refetch();
  }
};

Then in BatchActionBar:

<BatchActionBar
  ...
  customActions={
    <button
      disabled={actionLoading}
      className="bg-blue-100 text-blue-700 px-3 py-1 rounded"
      onClick={handleApprove}
    >
      {actionLoading ? "Processing..." : "Approve"}
    </button>
  }
/>

Done! Your table UI now:
	‚Ä¢	üîÑ Resets selection after each action
	‚Ä¢	üîî Gives instant feedback on success/failure
	‚Ä¢	‚ú® Feels polished and reliable for parents, admins, or coaches



let‚Äôs now wrap everything into a <ResourceTable /> component that gives you:

‚úÖ Reusable table for any resource (coaches, players, payments, etc.)
‚úÖ Built-in:
	‚Ä¢	Pagination
	‚Ä¢	Sorting
	‚Ä¢	Row selection
	‚Ä¢	Batch actions
	‚Ä¢	Toast feedback
‚úÖ Minimal setup in your page ‚Äî just pass endpoint, columns, and row ID getter

‚∏ª

‚úÖ 1. ResourceTable.tsx ‚Äî Full Smart Component

// components/table/ResourceTable.tsx

import { usePaginatedResource } from "@/hooks/usePaginatedResource";
import { PaginatedTable } from "./PaginatedTable";
import { BatchActionBar } from "./BatchActionBar";
import { showBatchToast, showErrorToast } from "@/lib/toast";

interface Column<T> {
  key: keyof T | string;
  label: string;
  sortable?: boolean;
  render?: (row: T) => React.ReactNode;
}

interface ResourceTableProps<T> {
  endpoint: string;
  columns: Column<T>[];
  getRowId: (row: T) => string;
  filters?: Record<string, string>;
  itemLabel?: string; // e.g., "coach", "player"
  onApprove?: (ids: string[]) => Promise<void>;
  onDelete?: (ids: string[]) => Promise<void>;
  onExport?: (ids: string[]) => Promise<void>;
  customActions?: (ids: string[]) => React.ReactNode;
}

export function ResourceTable<T>({
  endpoint,
  columns,
  getRowId,
  filters,
  itemLabel = "item",
  onApprove,
  onDelete,
  onExport,
  customActions,
}: ResourceTableProps<T>) {
  const resource = usePaginatedResource<T>({
    endpoint,
    getRowId,
    filters,
    initialSort: columns.find((c) => c.sortable)?.key as string,
  });

  const handleBatchAction = async (
    label: string,
    fn?: (ids: string[]) => Promise<void>
  ) => {
    if (!fn) return;
    try {
      await fn(resource.selectedIds);
      showBatchToast(label, resource.selectedIds.length, itemLabel);
    } catch (err: any) {
      showErrorToast(err?.response?.data?.message || `${label} failed`);
    } finally {
      resource.toggleSelectAllAcrossPages(false);
      resource.refetch();
    }
  };

  return (
    <>
      <PaginatedTable
        columns={columns}
        data={resource.data}
        loading={resource.loading}
        currentPage={resource.meta.page}
        total={resource.meta.total}
        pageSize={resource.meta.pageSize}
        onPageChange={resource.setPage}
        onSortChange={(key, dir) => {
          resource.setSort(key);
          resource.setOrder(dir);
          resource.setPage(1);
        }}
        currentSort={resource.sort}
        currentOrder={resource.order}
        selectableRows
        selectedRowIds={resource.selectedIds}
        onSelectAllAcrossPages={resource.toggleSelectAllAcrossPages}
        isAllSelectedAcrossPages={resource.selectAllAcrossPages}
        getRowId={getRowId}
        onSelectRows={() => {}}
      />

      <BatchActionBar
        selectedCount={resource.selectedIds.length}
        onClear={() => resource.toggleSelectAllAcrossPages(false)}
        onApprove={onApprove ? () => handleBatchAction("approved", onApprove) : undefined}
        onDelete={onDelete ? () => handleBatchAction("deleted", onDelete) : undefined}
        onExport={onExport ? () => handleBatchAction("exported", onExport) : undefined}
        customActions={customActions ? customActions(resource.selectedIds) : undefined}
      />
    </>
  );
}

2. Minimal Page Usage

<ResourceTable<Coach>
  endpoint="/admin/coaches"
  getRowId={(row) => row.id}
  itemLabel="coach"
  columns={[
    { key: "name", label: "Coach", sortable: true },
    { key: "email", label: "Email" },
    {
      key: "status",
      label: "Status",
      render: (row) => (
        <span className="text-xs px-2 py-1 rounded bg-yellow-100 text-yellow-700">
          {row.status}
        </span>
      ),
    },
  ]}
  onApprove={approveMultipleCoaches}
  onDelete={deleteMultipleCoaches}
  onExport={exportCoaches}
/>

Result
	‚Ä¢	‚úÖ 1-line resource table setup
	‚Ä¢	üí° Handles pagination, sorting, selection, batch actions, and toast UX
	‚Ä¢	‚ú® Admin-ready and easy to replicate for any resource


let‚Äôs enhance <ResourceTable /> with optional filter tabs like:

‚úÖ ‚ÄúAll‚Äù, ‚ÄúPending‚Äù, ‚ÄúApproved‚Äù, etc.
‚úÖ Built-in handling of tab-to-filter mapping
‚úÖ Auto-reloads data based on selected tab
‚úÖ Flexible for coaches, players, sessions, payments‚Ä¶


1. Extend ResourceTableProps with filterTabs

interface ResourceTableProps<T> {
  ...
  filterTabs?: {
    label: string;
    value: string;
    filters: Record<string, string>;
  }[];
  defaultTab?: string;
}

 2. Add Tab Bar + Filtering Logic

Inside <ResourceTable />:

import { useState } from "react";

export function ResourceTable<T>({
  ...props
}: ResourceTableProps<T>) {
  const [activeTab, setActiveTab] = useState(
    props.defaultTab || props.filterTabs?.[0]?.value || ""
  );

  const activeFilters =
    props.filterTabs?.find((t) => t.value === activeTab)?.filters || props.filters;

  const resource = usePaginatedResource<T>({
    endpoint: props.endpoint,
    getRowId: props.getRowId,
    filters: activeFilters,
    initialSort: props.columns.find((c) => c.sortable)?.key as string,
  });

  ...

Add Tab Bar JSX (above the table):

{props.filterTabs && (
  <div className="mb-4 flex gap-3 border-b">
    {props.filterTabs.map((tab) => (
      <button
        key={tab.value}
        onClick={() => setActiveTab(tab.value)}
        className={`px-3 py-2 text-sm font-medium border-b-2 ${
          activeTab === tab.value
            ? "border-blue-600 text-blue-700"
            : "border-transparent text-gray-500 hover:text-blue-600"
        }`}
      >
        {tab.label}
      </button>
    ))}
  </div>
)}

3. Use It in a Page

<ResourceTable<Coach>
  endpoint="/admin/coaches"
  getRowId={(c) => c.id}
  itemLabel="coach"
  columns={[
    { key: "name", label: "Coach", sortable: true },
    { key: "email", label: "Email" },
    {
      key: "status",
      label: "Status",
      render: (row) => (
        <span
          className={`px-2 py-1 text-xs rounded ${
            row.status === "approved"
              ? "bg-green-100 text-green-700"
              : "bg-yellow-100 text-yellow-700"
          }`}
        >
          {row.status}
        </span>
      ),
    },
  ]}
  filterTabs={[
    { label: "All", value: "all", filters: {} },
    { label: "Pending", value: "pending", filters: { status: "pending" } },
    { label: "Approved", value: "approved", filters: { status: "approved" } },
  ]}
  defaultTab="pending"
  onApprove={approveMultipleCoaches}
  onDelete={deleteMultipleCoaches}
/>

With this:
	‚Ä¢	You get built-in status filtering tabs
	‚Ä¢	Table auto-reloads when tabs switch
	‚Ä¢	Filters are cleanly scoped to tab definitions

 let‚Äôs now extend your <ResourceTable /> with tab-specific counts, like:

‚úÖ ‚ÄúAll (57)‚Äù, ‚ÄúPending (12)‚Äù, ‚ÄúApproved (45)‚Äù
‚úÖ Dynamically fetched via backend
‚úÖ Auto-updates when data changes or on reload
‚úÖ Adds clarity for admins or coaches reviewing statuses

 1. Update filterTabs Prop to Support Counts

interface ResourceTableProps<T> {
  ...
  filterTabs?: {
    label: string;
    value: string;
    filters: Record<string, string>;
    count?: number; // optional for preloaded
  }[];
}

But we‚Äôll dynamically load these counts, so you don‚Äôt have to pass them manually.

‚∏ª

‚úÖ 2. Add API Support (if not yet built)

On backend, create a route like:

GET /admin/coaches/status-counts

Returns:
{
  success: true,
  data: {
    all: 57,
    pending: 12,
    approved: 45
  }
}

3. Inside <ResourceTable />: Fetch Tab Counts

import { useEffect, useState } from "react";
import { apiGet } from "@/lib/api-client";

const [tabCounts, setTabCounts] = useState<Record<string, number>>({});

useEffect(() => {
  const fetchCounts = async () => {
    try {
      const res = await apiGet<{ [key: string]: number }>(
        `/admin/coaches/status-counts`
      );
      if (res.success && res.data) {
        setTabCounts(res.data);
      }
    } catch {
      setTabCounts({});
    }
  };

  if (props.filterTabs) fetchCounts();
}, []);

 4. Render Tabs with Counts

{props.filterTabs && (
  <div className="mb-4 flex gap-3 border-b">
    {props.filterTabs.map((tab) => (
      <button
        key={tab.value}
        onClick={() => setActiveTab(tab.value)}
        className={`px-3 py-2 text-sm font-medium border-b-2 ${
          activeTab === tab.value
            ? "border-blue-600 text-blue-700"
            : "border-transparent text-gray-500 hover:text-blue-600"
        }`}
      >
        {tab.label}
        {typeof tabCounts[tab.value] === "number" && (
          <span className="ml-1 text-xs text-gray-400">
            ({tabCounts[tab.value]})
          </span>
        )}
      </button>
    ))}
  </div>
)}


Final Example Output
	‚Ä¢	All (57)
	‚Ä¢	Pending (12)
	‚Ä¢	Approved (45)

‚∏ª

‚úÖ Optional: Auto-refresh tab counts after batch actions

In handleBatchAction(), after resource.refetch(), re-fetch tab counts too:

await fn(resource.selectedIds);
showBatchToast("approved", resource.selectedIds.length, "coach");
resource.toggleSelectAllAcrossPages(false);
resource.refetch();
fetchCounts(); // update tab counts

Perfect ‚Äî let‚Äôs now make the status counts API fully generic so you can reuse it for:

‚úÖ Coaches
‚úÖ Players
‚úÖ Payments
‚úÖ Sessions
‚úÖ Any resource with status or type fields


1. Create a Generic Backend Route

// GET /admin/status-counts?resource=coaches&statusField=status

// Example: /admin/status-counts?resource=players&statusField=approval_status

// Response:
{
  success: true,
  data: {
    all: 47,
    pending: 12,
    approved: 35
  }
}

 Implementation (Node/Express + Drizzle/Prisma)

app.get("/admin/status-counts", async (req, res) => {
  const { resource, statusField = "status" } = req.query;

  if (!resource) {
    return res.status(400).json({ success: false, message: "Missing resource param" });
  }

  try {
    const rows = await db.query[resource].findMany({
      columns: { [statusField]: true },
    });

    const counts: Record<string, number> = {};
    for (const row of rows) {
      const status = row[statusField] || "unknown";
      counts[status] = (counts[status] || 0) + 1;
    }

    const total = rows.length;
    return res.json({ success: true, data: { all: total, ...counts } });
  } catch (err) {
    return res.status(500).json({ success: false, message: "Query failed" });
  }
});

 2. Use It in <ResourceTable />

useEffect(() => {
  const fetchCounts = async () => {
    try {
      const res = await apiGet<{ [key: string]: number }>(
        `/admin/status-counts?resource=${resourceKey}&statusField=${statusField}`
      );
      if (res.success && res.data) {
        setTabCounts(res.data);
      }
    } catch {
      setTabCounts({});
    }
  };

  if (props.filterTabs) fetchCounts();
}, [resourceKey, statusField]);

3. Pass in Page

<ResourceTable<Coach>
  endpoint="/admin/coaches"
  getRowId={(c) => c.id}
  resourceKey="coaches"
  statusField="status"
  itemLabel="coach"
  ...
/>

 let‚Äôs extend your generic status-count system to support grouping by any field, not just status. This gives you:

‚úÖ Tabs like:
	‚Ä¢	‚ÄúRole: Coach / Parent / Admin‚Äù
	‚Ä¢	‚ÄúType: Training / Match / Camp‚Äù
	‚Ä¢	‚ÄúPayment: Paid / Pending / Failed‚Äù

‚úÖ Fully dynamic: works with any resource + field
‚úÖ One backend endpoint for all grouped tab counts

‚∏ª

‚úÖ 1. üîÅ Backend API: Group by Any Field


Route:
GET /admin/group-counts?resource=coaches&field=status

Query Parameters:
	‚Ä¢	resource: table name (e.g. players, sessions)
	‚Ä¢	field: field to group by (e.g. role, type, status)


Example Response:
{
  "success": true,
  "data": {
    "all": 42,
    "pending": 12,
    "approved": 28,
    "rejected": 2
  }
}

Backend Example (Node + Prisma or Drizzle):

app.get("/admin/group-counts", async (req, res) => {
  const { resource, field } = req.query;
  if (!resource || !field) {
    return res.status(400).json({ success: false, message: "Missing resource or field param" });
  }

  try {
    const rows = await db.query[resource].findMany({ columns: { [field]: true } });

    const counts: Record<string, number> = {};
    for (const row of rows) {
      const group = row[field] || "unknown";
      counts[group] = (counts[group] || 0) + 1;
    }

    const total = rows.length;
    return res.json({ success: true, data: { all: total, ...counts } });
  } catch (err) {
    return res.status(500).json({ success: false, message: "Failed to group counts" });
  }
});

2. Modify <ResourceTable /> Props


Add:
resourceKey: string;
groupField: string; // dynamic field name like "status", "role", "type"

3. Update Count Fetch Logic
const fetchCounts = async () => {
  try {
    const res = await apiGet<{ [key: string]: number }>(
      `/admin/group-counts?resource=${resourceKey}&field=${groupField}`
    );
    if (res.success && res.data) {
      setTabCounts(res.data);
    }
  } catch {
    setTabCounts({});
  }
};

4. Create Tabs Dynamically from Grouping

(Optional: you can build filterTabs from API response)

const dynamicTabs = Object.keys(tabCounts).map((key) => ({
  label: key[0].toUpperCase() + key.slice(1),
  value: key,
  filters: key === "all" ? {} : { [groupField]: key },
}));


 Final Usage Example

<ResourceTable<Player>
  endpoint="/admin/players"
  getRowId={(p) => p.id}
  resourceKey="players"
  groupField="role"
  itemLabel="player"
  columns={[
    { key: "name", label: "Player", sortable: true },
    { key: "email", label: "Email" },
    { key: "role", label: "Role" },
  ]}
  onApprove={approvePlayers}
  onDelete={deletePlayers}
/>

This now supports:
	‚Ä¢	Grouping by status, role, type, payment_status, etc.
	‚Ä¢	Dynamic tab counts
	‚Ä¢	One endpoint, many use cases


Perfect ‚Äî let‚Äôs enhance the tab system to support:

‚úÖ Custom labels per status/role/type
‚úÖ üó£ Internationalization (i18n) ready
‚úÖ Clean fallback to raw value if no label is given
‚úÖ Optional integration with libraries like react-i18next later

‚∏ª

‚úÖ 1. Update filterTabs or Grouping Config to Support Labels

Add optional labelMap:

interface ResourceTableProps<T> {
  ...
  groupField: string;
  resourceKey: string;
  labelMap?: Record<string, string>; // maps internal values ‚Üí display labels
}

2. Update Dynamic Tab Renderer


const dynamicTabs = Object.keys(tabCounts).map((key) => ({
  label: props.labelMap?.[key] || capitalize(key),
  value: key,
  filters: key === "all" ? {} : { [props.groupField]: key },
}));

Helper:

const capitalize = (s: string) => s.charAt(0).toUpperCase() + s.slice(1);

3. Example: i18n or Custom Status Labels

<ResourceTable<Session>
  endpoint="/admin/sessions"
  getRowId={(s) => s.id}
  resourceKey="sessions"
  groupField="type"
  itemLabel="session"
  labelMap={{
    all: "All Sessions",
    match: "Matches",
    training: "Training",
    camp: "Camps",
  }}
  columns={[
    { key: "title", label: "Session Name", sortable: true },
    { key: "type", label: "Type" },
  ]}
/>

 4. Optional: Integrate with react-i18next Later

import { useTranslation } from "react-i18next";

const { t } = useTranslation();

labelMap={{
  all: t("status.all"),
  pending: t("status.pending"),
  approved: t("status.approved"),
}}

Now you can:
	‚Ä¢	üè∑ Customize tab names to match your UX or brand
	‚Ä¢	üó∫ Localize for multi-language support
	‚Ä¢	üßº Fall back to sensible defaults if no label is found


Perfect ‚Äî let‚Äôs now use the same labelMap to format row values in the table, so values like:
	‚Ä¢	"pending" ‚Üí ‚ÄúUnder Review‚Äù
	‚Ä¢	"approved" ‚Üí ‚Äú‚úÖ Approved‚Äù
	‚Ä¢	"training" ‚Üí ‚Äúüèè Training Session‚Äù

‚úÖ Keeps your UI consistent
‚úÖ Reuses labelMap from the tab config
‚úÖ Supports i18n and emoji formatting
‚úÖ No need to define render manually for every column


1. Enhance PaginatedTable to Auto-Format with labelMap

interface PaginatedTableProps<T> {
  ...
  labelMap?: Record<string, string>; // Optional
}

In Row Renderer (<td> block), replace:

{col.render ? col.render(row) : String(row[col.key])}

With:

{col.render
  ? col.render(row)
  : props.labelMap?.[String(row[col.key])] || String(row[col.key])}

This lets labelMap override any raw value in the table, without a custom render.

 2. Pass labelMap from <ResourceTable> ‚Üí <PaginatedTable>

In your <ResourceTable>:

<PaginatedTable
  ...
  labelMap={props.labelMap}
/>


3. Final Usage Example (No Custom Render Needed)

<ResourceTable<Coach>
  endpoint="/admin/coaches"
  getRowId={(c) => c.id}
  resourceKey="coaches"
  groupField="status"
  itemLabel="coach"
  labelMap={{
    pending: "‚è≥ Under Review",
    approved: "‚úÖ Approved",
    rejected: "‚ùå Rejected",
    all: "All Coaches"
  }}
  columns={[
    { key: "name", label: "Coach" },
    { key: "email", label: "Email" },
    { key: "status", label: "Status" } // now auto-formatted using labelMap!
  ]}
/>

Now your UI is:
	‚Ä¢	üí¨ Consistent between tabs and table rows
	‚Ä¢	üåê i18n-ready from one config
	‚Ä¢	üí° Clean ‚Äî without needing custom renderers everywhere



