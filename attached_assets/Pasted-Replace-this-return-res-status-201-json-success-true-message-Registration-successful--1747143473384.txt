Replace this:

return res.status(201).json({
  success: true,
  message: "Registration successful!",
  user: userWithoutPassword
});

With:

import { createSuccessResponse } from "@/server/utils/api-response";

return res.status(201).json(
  createSuccessResponse({ user: userWithoutPassword }, "Registration successful!")
);


Make sure all your registration-related endpoints use this standard pattern â€” this includes /api/register, /api/register-firebase, /api/registerWithStandardCredentials, etc.

â¸»


Final Checklist

âœ… Ensure client uses res.data.user
âœ… Ensure server uses createSuccessResponse({ user })
âœ… Update test cases and Postman scripts if any expect old shape
âœ… Add console.log(response) in the client temporarily to verify structure

â¸»

ğŸ§ª Next: Test with Sample User

Run the following after deployment:

curl -sS http://localhost:5000/api/registerWithStandardCredentials \
  -X POST \
  -H "Content-Type: application/json" \
  -d '{"username":"maddy", "email":"maddy@gmail.com", "password":"Cricket2025!", "role":"coach", "phone":"1234567890"}'

You should now see:

{
  "success": true,
  "message": "Registration successful!",
  "data": {
    "user": { "id": ..., "email": "maddy@gmail.com", ... }
  }
}

generate a single shared registerUser() handler that all your register endpoints (firebase/local/standard) can use to centralize this logic?

 letâ€™s create a shared registerUser() utility function so all your registration endpoints (Firebase, local, standard credentials) reuse:

âœ… Common validation
âœ… Role + status setup
âœ… Database insert
âœ… Standardized response with createSuccessResponse()
âœ… Clean error handling


 Create registerUser.ts Utility


// server/services/registerUser.ts
import { db } from "@/server/db";
import { users } from "@/server/schema";
import { createSuccessResponse, createErrorResponse } from "@/server/utils/api-response";
import { hashPassword } from "@/server/utils/auth";

interface RegisterUserInput {
  username: string;
  email: string;
  password: string;
  role: "coach" | "parent" | "admin";
  phone?: string;
  provider?: "firebase" | "local" | "standard";
}

export async function registerUser(req, res, input: RegisterUserInput) {
  const { username, email, password, role, phone = "", provider = "standard" } = input;

  try {
    // Check for existing user
    const existing = await db.query.users.findFirst({
      where: (u, { eq }) => eq(u.email, email),
    });

    if (existing) {
      return res
        .status(409)
        .json(createErrorResponse("Email already registered"));
    }

    const hashedPassword = password ? await hashPassword(password) : undefined;

    const user = await db.insert(users).values({
      username,
      email,
      password: hashedPassword,
      role,
      phone,
      provider,
      status: role === "coach" ? "pending_approval" : "active",
    }).returning().then((r) => r[0]);

    // TODO: optionally trigger admin notification or welcome email

    return res
      .status(201)
      .json(createSuccessResponse({ user }, "Registration successful!"));
  } catch (err) {
    console.error("Registration error:", err);
    return res
      .status(500)
      .json(createErrorResponse("Registration failed. Please try again."));
  }
}

2. Use It in Your Server Routes


In /api/register, /api/registerWithStandardCredentials, etc.:

import { registerUser } from "@/server/services/registerUser";

app.post("/api/register", async (req, res) => {
  await registerUser(req, res, {
    username: req.body.username,
    email: req.body.email,
    password: req.body.password,
    role: req.body.role,
    phone: req.body.phone,
    provider: "standard",
  });
});


You can reuse this in:
	â€¢	/api/registerWithStandardCredentials
	â€¢	/api/auth/register-firebase (just omit password)
	â€¢	/api/auth/local-register

Result
	â€¢	ğŸ“¦ Reusable logic across all flows
	â€¢	ğŸ§¼ Cleaner routes â€” just parse input and call registerUser()
	â€¢	ğŸ” Built-in role/status defaults + hashing
	â€¢	ğŸ§ª Easier testing, mocking, and future logging

like to also create a validateRegisterInput() function with Zod to plug in before calling registerUser() for stronger input safety?

letâ€™s now add validateRegisterInput() with Zod for:

âœ… Strong type-safe validation
âœ… Required field checks (email, username, password, etc.)
âœ… Enum enforcement for role and provider
âœ… Clean separation between validation and registration logic
âœ… Reusable across all register endpoints


. Install Zod (if not already)

npm install zod

 Create validation/registerSchema.ts

// server/validation/registerSchema.ts
import { z } from "zod";

export const registerUserSchema = z.object({
  username: z.string().min(2).max(50),
  email: z.string().email(),
  password: z
    .string()
    .min(8, "Password must be at least 8 characters")
    .regex(/[A-Z]/, "Must include an uppercase letter")
    .regex(/[a-z]/, "Must include a lowercase letter")
    .regex(/[0-9]/, "Must include a number"),
  role: z.enum(["coach", "parent", "admin"]),
  phone: z.string().optional(),
  provider: z.enum(["firebase", "local", "standard"]).optional(),
});

export type RegisterUserInput = z.infer<typeof registerUserSchema>;

3. Validate in registerUser.ts

import { registerUserSchema, RegisterUserInput } from "@/server/validation/registerSchema";

export async function registerUser(req, res, input: any) {
  try {
    // âœ… Validate input first
    const validated = registerUserSchema.parse(input);

    const { username, email, password, role, phone = "", provider = "standard" } = validated;

    // ...existing logic...

Now if any field is missing or invalid, it throws immediately.


4. Handle Zod Errors Gracefully

  } catch (err) {
    if (err instanceof z.ZodError) {
      const message = err.issues.map(i => i.message).join(", ");
      return res.status(400).json(createErrorResponse(message));
    }

    console.error("Registration error:", err);
    return res.status(500).json(createErrorResponse("Registration failed"));
  }

5. Your Route Now Looks Like:


app.post("/api/register", async (req, res) => {
  await registerUser(req, res, req.body);
});


Example Validation Failure Response

{
  "success": false,
  "message": "Must include an uppercase letter, Must include a number"
}

You now have:
	â€¢	ğŸ” Strong validated inputs
	â€¢	ğŸ’¬ Helpful user-friendly errors
	â€¢	ğŸ§¼ Cleaner server logic
	â€¢	â™»ï¸ Schema reuse in tests or frontend if needed

